{
	
	"factorization": {
		"prefix": "factorization",
		"body": [
		  "void factorization(int n){",
		  "    int node = n ;",
		  "",
		  "    for(auto x : primelist){",
		  "        if(x*x > n) break ;",
		  "        while(n%x == 0){",
		  "            cout << x << \" \";",
		  "            n /= x;",
		  "        }",
		  "    }",
		  "    if(n > 1)",
		  "        cout << n << \" \";",
		  "    cout << endl ;",
		  "}"
		],
		"description": "factorization"
	  },
	  "Faster Input Output": {
		"prefix": "boost",
		"body": [
		  "ios_base::sync_with_stdio(false);",
		  "cin.tie(0);",
		  "$0"
		],
		"description": "Faster Input Output"
	  },
	  "lcm": {
		"prefix": "lcm",
		"body": [
		  "long long int lcm(long long int a, long long int b){",
		  "	return ( (a*b)/__gcd(a,b) ) ;",
		  "}"
		],
		"description": "lcm"
	  },
	  "BigMod": {
		"prefix": "BigMod",
		"body": [
		  "long long int BigMod(long long int num , long long int power, long long int mod){",
		  "	",
		  "	if(power == 0 ){",
		  "		return 1 ;",
		  "	}",
		  "	long long int x = 1 ;",
		  "	if(power&1){",
		  "		x = num ;",
		  "	}",
		  "	long long int y = BigMod(num,power/2,mod) ;",
		  "	y = ( y%mod * y%mod )%mod ;",
		  "	return (y%mod * x%mod)%mod ;",
		  "}"
		],
		"description": "BigMod"
	  },
	  "BigModInverse": {
		"prefix": "BigModInverse",
		"body": [
		  "long long int BigMod(long long int num , long long int power, long long int mod){",
		  "	",
		  "	if(power == 0 ){",
		  "		return 1 ;",
		  "	}",
		  "	long long int x = 1 ;",
		  "	if(power&1){",
		  "		x = num ;",
		  "	}",
		  "	long long int y = BigMod(num,power/2,mod) ;",
		  "	y = ( y%mod * y%mod )%mod ;",
		  "	return (y%mod * x%mod)%mod ;",
		  "	",
		  "}",
		  "long long int BigModInverse(long long int num , long long int mod ){",
		  "",
		  "	return BigMod(num,mod-2,mod) ;",
		  "}"
		],
		"description": "BigModInverse"
	  },
	  "BigIntergerAddition": {
		"prefix": "BigIntergerAddition",
		"body": [
		  "string addString (string a, string b){",
		  "	int l1 = a.size() , l2 = b.size();",
		  "	if(l1 > l2){",
		  "		swap(a,b);",
		  "		swap(l1,l2);",
		  "	}",
		  "	string ans =\"\";",
		  "	reverse(a.begin(),a.end());",
		  "	reverse(b.begin(),b.end());",
		  "	bool carry = false;",
		  "	",
		  "	for(int i = 0 ;i < l1 ; i++){",
		  "		int temp = (a[i]-'0') + (b[i]-'0') + (carry);",
		  "		carry = false;",
		  "		if(temp > 9){",
		  "			carry = true;",
		  "			temp = temp-10;",
		  "		}",
		  "		ans += (temp+'0');",
		  "	}",
		  "	for(int i = l1 ; i < l2 ; i++){",
		  "		int temp = (b[i]-'0') + (carry);",
		  "		carry = false;",
		  "		if(temp > 9){",
		  "			carry = true;",
		  "			temp = temp-10;",
		  "		}",
		  "		ans += (temp+'0');",
		  "	}",
		  "	if(carry) ans += '1';",
		  "	reverse(ans.begin(),ans.end());",
		  "	",
		  "	return ans;",
		  "}"
		],
		"description": "BigIntergerAddition"
	  },
	  "BigIntergerMultiplication": {
		"prefix": "BigIntergerMultiplication",
		"body": [
		  "string addStringModified (string a, string b){",
		  "	reverse(a.begin(),a.end());",
		  "	int l1 = a.size() , l2 = b.size();",
		  "	if(l1 > l2){",
		  "		swap(a,b);",
		  "		swap(l1,l2);",
		  "	}",
		  "	string ans =\"\";",
		  "",
		  "	bool carry = false;",
		  "	",
		  "	for(int i = 0 ;i < l1 ; i++){",
		  "		int temp = (a[i]-'0') + (b[i]-'0') + (carry);",
		  "		carry = false;",
		  "		if(temp > 9){",
		  "			carry = true;",
		  "			temp = temp-10;",
		  "		}",
		  "		ans += (temp+'0');",
		  "	}",
		  "	for(int i = l1 ; i < l2 ; i++){",
		  "		int temp = (b[i]-'0') + (carry);",
		  "		carry = false;",
		  "		if(temp > 9){",
		  "			carry = true;",
		  "			temp = temp-10;",
		  "		}",
		  "		ans += (temp+'0');",
		  "	}",
		  "	if(carry) ans += '1';",
		  "	reverse(ans.begin(),ans.end());",
		  "	",
		  "	return ans;",
		  "}",
		  "",
		  "string multiplication(string s, ll n ){",
		  "	",
		  "	reverse(s.begin() , s.end() ) ;",
		  "",
		  "	string ans = \"0\";",
		  "	int koy_number = 0 ;",
		  "	while( n!= 0 ){",
		  "		int num = n%10 ;",
		  "		n /= 10 ;",
		  "		",
		  "		int carry = 0 ;",
		  "		",
		  "		string temp = \"\";",
		  "		for(auto x : s ) {",
		  "			int y = carry + (x - '0' ) * num;",
		  "			carry = 0;",
		  "			if( y > 9 ){",
		  "				carry = y / 10 ;",
		  "				y %= 10;",
		  "			}",
		  "			",
		  "			temp += char( y + '0' ) ;",
		  "		}",
		  "		if(carry) temp += char(carry + '0' ) ;",
		  "		",
		  "		string zero = \"\";",
		  "		for(int i = 0 ; i < koy_number ; i++) {",
		  "			zero += '0' ;",
		  "		}",
		  "		temp = zero + temp ;",
		  "		ans = addStringModified(ans,temp) ;",
		  "		koy_number ++;",
		  "		",
		  "	}",
		  "",
		  "	return ans ; ",
		  "}",
		  ""
		],
		"description": "BigIntergerMultiplication"
	  },
	  "my_full_template": {
		"prefix": "my_full_template",
		"body": [
		  "				/*Saurav Paul*/",
		  "#include<bits/stdc++.h>",
		  "using namespace std;",
		  "",
		  "#define ll 					  long long int",
		  "#define boost		          ios_base::sync_with_stdio(0);",
		  "#pragma GCC optimize(\"O3\")",
		  "#define loop(i,a,b)           for(ll i=a;i<=b;++i)",
		  "#define eb                    emplace_back",
		  "#define itoc(c)               ((char)(((int)'0')+c))",
		  "#define ctoi(c)               ((int)(((int)c)-'0'))",
		  "#define all(p)                p.begin(),p.end()",
		  "#define bug()				  debug() <<",
		  "",
		  "///////////////////////",
		  "",
		  "#define sim template < class c",
		  "#define ris return * this",
		  "#define dor > debug & operator <<",
		  "#define eni(x) sim > typename \\",
		  "enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {",
		  "sim > struct rge { c b, e; };",
		  "sim > rge<c> range(c i, c j) { return rge<c>{i, j}; }",
		  "sim > auto dud(c* x) -> decltype(cerr << *x, 0);",
		  "sim > char dud(...);",
		  "struct debug {",
		  "#ifdef PAUL",
		  "~debug() { cerr << endl; }",
		  "eni(!=) cerr << boolalpha << i; ris; }",
		  "eni(==) ris << range(begin(i), end(i)); }",
		  "sim, class b dor(pair < b, c > d) {",
		  "  ris << \"(\" << d.first << \", \" << d.second << \")\";",
		  "}",
		  "sim dor(rge<c> d) {",
		  "  *this << \"[\";",
		  "  for (auto it = d.b; it != d.e; ++it)",
		  "	*this << \", \" + 2 * (it == d.b) << *it;",
		  "  ris << \"]\";",
		  "}",
		  "#else",
		  "sim dor(const c&) { ris; }",
		  "#endif",
		  "};",
		  "#define dbg(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"",
		  "",
		  "#ifdef ONLINE_JUDGE",
		  "#define cerr if (false) cerr",
		  "#endif",
		  "int main() ;",
		  "void file(){",
		  "	#ifdef PAUL",
		  "		freopen(\"in.txt\",\"r\",stdin);",
		  "		//freopen(\"out.txt\",\"w\",stdout);",
		  "	#endif",
		  "}",
		  "void time(){",
		  "	#ifdef PAUL",
		  "		cerr << \"\\nTime elapsed: \" << (double)(1.0 * (double)clock() / CLOCKS_PER_SEC) << \" s.\\n\";",
		  "	#endif",
		  "}",
		  "///////////////////////",
		  "const int INF = 1e9 + 90;",
		  "const ll LINF = 1e18 + 90 ;",
		  "using pii = pair<int,int >;",
		  "using vec = vector<int> ;",
		  "",
		  "int main()",
		  "{",
		  "	",
		  "",
		  "	return 0;",
		  "}",
		  ""
		],
		"description": "my_full_template"
	  },
	  "testcase": {
		"prefix": "testcase",
		"body": [
		  "int testcase;",
		  "cin >> testcase;",
		  "for (int t = 1; t <= testcase; t++){",
		  "	solve();",
		  "}"
		],
		"description": "testcase"
	  },
	  "ll": {
		"prefix": "ll",
		"body": [
		  "long long int"
		],
		"description": "ll"
	  },
	  "lowerbound": {
		"prefix": "lowerbound",
		"body": [
		  "int lowerbound(vector<int> &v,int value){",
		  "	int low = 0 , high = (int) v.size();",
		  "	while(low < high){",
		  "		int mid = low + ((high - low) >> 1);",
		  "		if(v[mid] < value ) low = mid + 1;",
		  "		else high = mid ;",
		  "	}",
		  "	return low ;",
		  "}"
		],
		"description": "lowerbound"
	  },
	  "upperbound": {
		"prefix": "upperbound",
		"body": [
		  "int upperbound(vector<int> &v,int value){",
		  "	int low = 0 , high = (int) v.size();",
		  "	while(low < high){",
		  "		int mid = low + ( ( high-low) >> 1 );",
		  "		if(v[mid] <= value) low = mid + 1;",
		  "		else high = mid ;",
		  "	}",
		  "	return low;",
		  "}"
		],
		"description": "upperbound"
	  },
	  "kmp": {
		"prefix": "kmp",
		"body": [
		  "class kmp{",
		  "	public :",
		  "	void find_kmp(string &s, string &pattern){",
		  "		int sz = (int)pattern.size();",
		  "		vector<int> suffix(sz), matched;",
		  "		build_suffix_array(suffix,pattern,sz);",
		  "		",
		  "		int n = (int) s.size();",
		  "		for(int i = 0,j=0 ; j < n; ){",
		  "			if(s[j]==pattern[i]){",
		  "				i++;",
		  "				j++;",
		  "				if(i==sz){",
		  "					matched.emplace_back(j-sz);",
		  "					if(i)",
		  "						i = suffix[i-1];",
		  "				}",
		  "			}",
		  "			else{",
		  "				if(i){",
		  "					i = suffix[i-1];",
		  "				}",
		  "				else{",
		  "					j++;",
		  "				}",
		  "			}",
		  "		}",
		  "		printf(\"Total matched : %d\\n\",(int)matched.size());",
		  "		",
		  "		for(int x : matched)",
		  "			printf(\"%d \",x);",
		  "		puts(\"\");",
		  "		",
		  "	}",
		  "	",
		  "	private :",
		  "	void build_suffix_array(vector<int> &suffix,string & s,int sz){",
		  "		/** a b c d a b c y",
		  "			0 0 0 0 1 2 3 0",
		  "		**/",
		  "		for(int i = 0 , j = 1 ; j < sz ; ){",
		  "			",
		  "			if(s[i]==s[j]){",
		  "				suffix[j] = i+1;",
		  "				i++ , j++;",
		  "			}",
		  "			else{",
		  "				if(i){",
		  "					i = suffix[i-1] ;",
		  "				}",
		  "				else{",
		  "					suffix[j] = 0;",
		  "					j++;",
		  "				}",
		  "			}",
		  "		}",
		  "		",
		  "	}",
		  "};"
		],
		"description": "kmp"
	  }
	  ,
	  "Rabin_Karp": {
		"prefix": "Rabin_Karp",
		"body": [
		  "void Rabin_Karp(string &s,string &pattern){",
		  "	",
		  "	int plen = (int)pattern.size();",
		  "	int slen = (int)s.size();",
		  "	vector<int> match;",
		  "	long long int hash = 0,patternHash=0 , prime = 3;",
		  "	// finding patternhash and the first part hash...",
		  "	for(int i=0 ; i < plen ; i++){",
		  "		hash += s[i] * pow(prime,i);",
		  "		patternHash += pattern[i] * pow(prime,i);",
		  "		",
		  "	}",
		  "	// checking if first part is same...",
		  "	if(patternHash == hash)",
		  "		match.emplace_back(0);",
		  "	for(int i = plen ; i < slen ; i++){",
		  "		hash -= s[i-plen];",
		  "		hash /=prime;",
		  "		hash += s[i] * pow(prime,plen-1);",
		  "		//cerr << patternHash <<\" \"<<hash << endl;",
		  "		if(patternHash == hash)",
		  "		{",
		  "			bool flag = true;",
		  "			for(int j = i-plen+1,k=0 ; j <= i ; j++,k++){",
		  "				if(s[j] != pattern[k]){",
		  "					flag = false;",
		  "					break ;",
		  "				}",
		  "			}",
		  "			if(flag)",
		  "				match.emplace_back(i-plen+1);",
		  "		}",
		  "	}",
		  "	",
		  "	// printing all matched starting points..",
		  "	printf(\"Total matched : %d\\n\",(int)match.size());",
		  "	for(auto x : match)",
		  "		printf(\"%d \",x);",
		  "		",
		  "	return ;",
		  "}"
		],
		"description": "Rabin_Karp"
	  },
	  "sieve": {
		"prefix": "sieve",
		"body": [
		  "vector<int> primelist;",
		  "",
		  "void sieve(int lim){",
		  "	bool rem[lim+70]={};",
		  "	primelist.emplace_back(2);",
		  "",
		  "	for(int i =4 ; i <= lim ; i+=2)",
		  "		rem[i] = true;",
		  "	for(int i = 3 ; i <= lim ; i+= 2){",
		  "		if(rem[i]==false){",
		  "			primelist.emplace_back(i);",
		  "			for(int j = 2*i + i ; j <= lim ; j += 2*i)",
		  "				rem[j] = true;",
		  "		}",
		  "	}",
		  "}"
		],
		"description": "sieve"
	  },
	  "debug_template": {
		"prefix": "debug_template",
		"body": [
		  "",
		  "#define bug()				  debug() <<",
		  "#define sim template < class c",
		  "#define ris return * this",
		  "#define dor > debug & operator <<",
		  "#define eni(x) sim > typename \\",
		  "enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {",
		  "sim > struct rge { c b, e; };",
		  "sim > rge<c> range(c i, c j) { return rge<c>{i, j}; }",
		  "sim > auto dud(c* x) -> decltype(cerr << *x, 0);",
		  "sim > char dud(...);",
		  "struct debug {",
		  "#ifdef PAUL",
		  "~debug() { cerr << endl; }",
		  "eni(!=) cerr << boolalpha << i; ris; }",
		  "eni(==) ris << range(begin(i), end(i)); }",
		  "sim, class b dor(pair < b, c > d) {",
		  "  ris << \"(\" << d.first << \", \" << d.second << \")\";",
		  "}",
		  "sim dor(rge<c> d) {",
		  "  *this << \"[\";",
		  "  for (auto it = d.b; it != d.e; ++it)",
		  "	*this << \", \" + 2 * (it == d.b) << *it;",
		  "  ris << \"]\";",
		  "}",
		  "#else",
		  "sim dor(const c&) { ris; }",
		  "#endif",
		  "};",
		  "#define dbg(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"",
		  "",
		  "#ifdef ONLINE_JUDGE",
		  "#define cerr if (false) cerr",
		  "#endif"
		],
		"description": "debug_template"
	  },
	  "c++": {
		"prefix": "c++",
		"body": [
		  "				/*Saurav Paul*/",
		  "#include<bits/stdc++.h>",
		  "using namespace std;",
		  "",
		  "int main(){",
		  "	",
		  "	$0",
		  "",
		  "	return 0;",
		  "}",
		  ""
		],
		"description": "c++"
	  },
	  "solve": {
		"prefix": "solve",
		"body": [
		  "void solve() {",
		  "",
		  "	$0",
		  "}"
		],
		"description": "solve"
	  },
	  "bit operation": {
		"prefix": "bit_function",
		"body": [
		  "template<typename T>T set_bit(T N,T pos){return N=N | (1<<pos);}",
		  "template<typename T>T reset_bit(T N,T pos){return N= N & ~(1<<pos);}",
		  "template<typename T> bool check_bit(T N,T pos){return (bool)(N & (1<<pos));}",
		  "template<typename T>void bin_print(T N){bitset<25>bit(N);cerr<<bit.to_string()<<\"\\n\";}"
		],
		"description": "bit operation"
	  },
	  "loop ": {
		"prefix": "loop",
		"body": [
		  "for($1 ; $2 ; $3){",
		  "	$0",
		  "}"
		],
		"description": "loop "
	  },
	  "vi": {
		"prefix": "vi",
		"body": [
		  "vector<int>"
		],
		"description": "vi"
	  },
	  "vll": {
		"prefix": "vll",
		"body": [
		  "vector<long long int> "
		],
		"description": "vll"
	  },
	  "mp": {
		"prefix": "mp",
		"body": [
		  "make_pair($1,$2)"
		],
		"description": "mp"
	  },
	  "eb": {
		"prefix": "eb",
		"body": [
		  "emplace_back($1) ;"
		],
		"description": "eb"
	  },
	  "all()": {
		"prefix": "all()",
		"body": [
		  "$1.begin(),$1.end()"
		],
		"description": "all()"
	  },
	  

	  


}